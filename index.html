<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>SSVEP 実験選択</title>
  <style>
    body {
      margin: 0;
      background-color: black;
      color: white;
      font-family: sans-serif;
      text-align: center;
      overflow: hidden;
    }

    h1 {
      margin-top: 15%;
      font-size: 48px;
    }

    .menu-button {
      display: inline-block;
      margin: 40px;
      padding: 20px 60px;
      font-size: 32px;
      background-color: #333;
      border: none;
      border-radius: 10px;
      color: white;
      cursor: pointer;
    }

    .menu-button:hover {
      background-color: #666;
    }

    #experiment-container {
      display: none;
    }

    .square {
      width: 300px;
      height: 300px;
      background-color: black;
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      border: 4px solid transparent;
      box-sizing: border-box;
      transition: border 0.2s;
    }

    .square:hover {
      border: 4px solid red;
    }

    #left {
      left: calc(50% - 400px);
    }

    #right {
      left: calc(50% + 100px);
    }
    #arrow {
      position: absolute;
      top: 50%;
      left: 50%;
      font-size: 100px;
      transform: translate(-50%, -50%);
      visibility: hidden;
    }

    #countdown {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 80px;
    }

    #restart-btn, #back-btn {
      position: absolute;
      top: 70%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 32px;
      background-color: #444;
      color: white;
      padding: 10px 30px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      visibility: hidden;
    }

    #restart-btn:hover, #back-btn:hover {
      background-color: #666;
    }
  </style>
</head>
<body>
  <!-- === 実験選択画面 === -->
  <div id="menu">
    <h1>実験を選択してください</h1>
    <button class="menu-button" id="exp1-btn">実験1</button>
    <button class="menu-button" id="exp2-btn">実験2</button>
  </div>

  <!-- === 実験画面 === -->
  <div id="experiment-container">
    <div id="left" class="square"></div>
    <div id="right" class="square"></div>
    <div id="arrow"></div>
    <div id="countdown"></div>
    <button id="restart-btn">もう一度実験を行う</button>
    <button id="back-btn">実験選択に戻る</button>
  </div>

  <script>
    const menu = document.getElementById("menu");
    const container = document.getElementById("experiment-container");
    const left = document.getElementById("left");
    const right = document.getElementById("right");
    const arrow = document.getElementById("arrow");
    const countdown = document.getElementById("countdown");
    const restartBtn = document.getElementById("restart-btn");
    const backBtn = document.getElementById("back-btn");

    let currentExperiment = null;

    // ===== 実験選択 =====
    document.getElementById("exp1-btn").onclick = () => startExperiment(1);
    document.getElementById("exp2-btn").onclick = () => startExperiment(2);

    function startExperiment(n) {
      currentExperiment = n;
      menu.style.display = "none";
      container.style.display = "block";
      runExperiment();
    }

    // ===== 安静・カウントダウン共通関数 =====
    function rest(duration, label = "安静") {
      return new Promise(resolve => {
        countdown.textContent = label;
        setTimeout(() => {
          countdown.textContent = "";
          resolve();
        }, duration);
      });
    }

    function showCountdown(seconds) {
      return new Promise(resolve => {
        let count = seconds;
        countdown.textContent = count;
        const timer = setInterval(() => {
          count--;
          if (count > 0) countdown.textContent = count;
          else {
            clearInterval(timer);
            countdown.textContent = "";
            resolve();
          }
        }, 1000);
      });
    }

    // ===== 実験1：片側点滅 =====
    async function startFlicker(element, freq, duration, direction) {
      return new Promise(resolve => {
        let visible = true;
        const interval = 1000 / (freq * 2);
        arrow.textContent = direction === "left" ? "←" : "→";
        arrow.style.visibility = "visible";

        const flickerInterval = setInterval(() => {
          element.style.backgroundColor = visible ? "white" : "black";
          visible = !visible;
        }, interval);

        setTimeout(() => {
          clearInterval(flickerInterval);
          element.style.backgroundColor = "black";
          arrow.style.visibility = "hidden";
          resolve();
        }, duration);
      });
    }

    // ===== 実験2：同時点滅 =====
    async function startDualFlicker(leftFreq, rightFreq, duration, direction) {
      return new Promise(resolve => {
        let t0 = performance.now();
        arrow.textContent = direction === "left" ? "←" : "→";
        arrow.style.visibility = "visible";

        function animate(timestamp) {
          const t = (timestamp - t0) / 1000;
          left.style.backgroundColor = Math.sin(2 * Math.PI * leftFreq * t) > 0 ? "white" : "black";
          right.style.backgroundColor = Math.sin(2 * Math.PI * rightFreq * t) > 0 ? "white" : "black";
          if (timestamp - t0 < duration) requestAnimationFrame(animate);
          else {
            left.style.backgroundColor = "black";
            right.style.backgroundColor = "black";
            arrow.style.visibility = "hidden";
            resolve();
          }
        }
        requestAnimationFrame(animate);
      });
    }

    // ===== 実験実行 =====
    async function runExperiment() {
      restartBtn.style.visibility = "hidden";
      backBtn.style.visibility = "hidden";
      countdown.textContent = "安静";
      await rest(5000);
      await showCountdown(5);

      if (currentExperiment === 1) {
        await startFlicker(left, 5, 5000, "left");
        await rest(3000);
        await startFlicker(right, 12, 5000, "right");
        await rest(3000);
        await startFlicker(left, 6, 5000, "left");
        await rest(3000);
        await startFlicker(right, 10, 5000, "right");
      } else if (currentExperiment === 2) {
        await startDualFlicker(5, 12, 5000, "left");
        await rest(3000);
        await startDualFlicker(5, 12, 5000, "right");
        await rest(5000);
        await showCountdown(5);
        await startDualFlicker(6, 10, 5000, "left");
        await rest(3000);
        await startDualFlicker(6, 10, 5000, "right");
      }

      countdown.textContent = "実験終了";
      restartBtn.style.visibility = "visible";
      backBtn.style.visibility = "visible";
    }

    restartBtn.onclick = () => {
      countdown.textContent = "";
      runExperiment();
    };

    backBtn.onclick = () => {
      container.style.display = "none";
      menu.style.display = "block";
      countdown.textContent = "";
    };

    // ===== iPhone向けタッチ対応 =====
    [left, right].forEach(el => {
      el.addEventListener("touchstart", () => el.style.border = "4px solid red");
      el.addEventListener("touchend", () => el.style.border = "4px solid transparent");
    });
  </script>
</body>
</html>
